# pytorch

1.张量表示由一个数值组成的数组，这个数组可能有多个维度

(tf) tjing@tjing:~$ python
Python 3.9.16 (main, Mar  8 2023, 14:00:05) 
[GCC 11.2.0] :: Anaconda, Inc. on linux
Type "help", "copyright", "credits" or "license" for more information.
        >>> import torch
        >>> x = torch.arange(12)
        >>> x
        tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

2.可以通过张量的 shape 属性来访问张量的形状 和张量中元素的总数

        >>> x.shape
        torch.Size([12])
        >>> x.numel()
        12

3.要改变一个张量的形状而不改变元素数量和元素值，可以调用 reshape 函数
        >>> X = x.reshape(3, 4)
        >>> X
        tensor([[ 0,  1,  2,  3],
                [ 4,  5,  6,  7],
                [ 8,  9, 10, 11]])

4.使用全0、全1、其他常量或者从特定分布中随机采样的数字

        >>> torch.zeros((2, 3, 4))
        tensor([[[0., 0., 0., 0.],
                 [0., 0., 0., 0.],
                 [0., 0., 0., 0.]],
        
                [[0., 0., 0., 0.],
                 [0., 0., 0., 0.],
                 [0., 0., 0., 0.]]])
        >>> torch.ones((2, 3, 4))
        tensor([[[1., 1., 1., 1.],
                 [1., 1., 1., 1.],
                 [1., 1., 1., 1.]],
        
                [[1., 1., 1., 1.],
                 [1., 1., 1., 1.],
                 [1., 1., 1., 1.]]])
        >>> torch.randn(3, 4)
        tensor([[ 0.0290,  1.1335, -0.0475,  1.7365],
                [-1.4809,  0.3857,  1.2348, -0.3070],
                [ 2.4078,  2.0319, -0.2232,  0.6141]])

5.通过提供包含数值的 Python 列表（或嵌套列表）来为所需张量中的每个元素赋予确定值

        >>> torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
        tensor([[2, 1, 4, 3],
                [1, 2, 3, 4],
                [4, 3, 2, 1]])

6.常见的标准算术运算符（+、-、*、/ 和 **）都可以被升级为按元素运算
        >>> x = torch.tensor([1.0, 2, 4, 8])
        >>> y = torch.tensor([2, 2, 2, 2])
        >>> x + y, x - y, x * y, x / y, x**y
        (tensor([ 3.,  4.,  6., 10.]), 
        tensor([-1.,  0.,  2.,  6.]), 
        tensor([ 2.,  4.,  8., 16.]), 
        tensor([0.5000, 1.0000, 2.0000, 4.0000]), 
        tensor([ 1.,  4., 16., 64.]))

7.按按元素方式应用更多的计算
        >>> torch.exp(x)
        tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])

8.我们也可以把多个张量 连结（concatenate） 在一起
        >>> X = torch.arange(12, dtype=torch.float32).reshape((3, 4))
        >>> Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
        >>> torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
        (tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.],
                [ 2.,  1.,  4.,  3.],
                [ 1.,  2.,  3.,  4.],
                [ 4.,  3.,  2.,  1.]]), 
        tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
                [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
                [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))

8.通过 逻辑运算符 构建二元张量
        >>> X == Y
        tensor([[False,  True, False,  True],
                [False, False, False, False],
                [False, False, False, False]])

9.对张量中的所有元素进行求和会产生一个只有一个元素的张量
        >>> X.sum()
        tensor(66.)

10.即使形状不同，我们仍然可以通过调用 广播机制 （broadcasting mechanism） 来执行按元素操作
        >>> a = torch.arange(3).reshape((3, 1))
        >>> b = torch.arange(2).reshape((1, 2))
        >>> a, b
        (tensor([[0],
                [1],
                [2]]), 
        tensor([[0, 1]]))
        
        >>> a + b
        tensor([[0, 1],
                [1, 2],
                [2, 3]])

11.可以用 [-1] 选择最后一个元素，可以用 [1:3] 选择第二个和第三个元素
        >>> X
        tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.]])
        
        >>> X[-1], X[1:3]
        (tensor([ 8.,  9., 10., 11.]), 
        tensor([[ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.]]))

12.除读取外，我们还可以通过指定索引来将元素写入矩阵
        >>> X
        tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.]])
        >>> X[1, 2] = 9
        >>> X
        tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  9.,  7.],
                [ 8.,  9., 10., 11.]])

13.为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值
        >>> X[0:2, :] = 12
        >>> X
        tensor([[12., 12., 12., 12.],
                [12., 12., 12., 12.],
                [ 8.,  9., 10., 11.]])

14.运行一些操作可能会导致为新结果分配内存
        >>> before = id(Y)
        >>> Y = Y + X
        >>> id(Y) == before
        False

15.执行原地操作
        >>> Z = torch.zeros_like(Y)
        >>> print('id(Z):', id(Z))
        id(Z): 140136274633328
        
        >>> Z[:] = X + Y
        >>> print('id(Z):', id(Z))
        id(Z): 140136274633328

16.如果在后续计算中没有重复使用 X，我们也可以使用 X[:] = X + Y 或 X += Y 来减少操作的内存开销
        >>> before = id(X)
        >>> X += Y
        >>> id(X) == before
        True

17.转换为 NumPy 张量
        >>> X
        tensor([[26., 25., 28., 27.],
                [25., 26., 27., 28.],
                [20., 21., 22., 23.]])
        
        >>> type(X)
        <class 'torch.Tensor'>
        
        >>> A = X.numpy()
        >>> B = torch.tensor(A)
        >>> type(A), type(B)
        (<class 'numpy.ndarray'>, <class 'torch.Tensor'>)

18.将大小为1的张量转换为 Python 标量
        >>> a = torch.tensor([3.5])
        >>> a, a.item(), float(a), int(a)
        (tensor([3.5000]), 3.5, 3.5, 3)
