# pytorch

1.标量由只有一个元素的张量表示
    >>> import torch
    >>> x = torch.tensor([3.0])
    >>> y = torch.tensor([2.0])
    >>> x + y, x * y, x / y, x**y
    (tensor([5.]), tensor([6.]), tensor([1.5000]), tensor([9.])) `


2.你可以将向量视为标量值组成的列表
    >>> x = torch.arange(4)
    >>> x
    tensor([0, 1, 2, 3])

3.通过张量的索引来访问任一元素
    tensor([0, 1, 2, 3])
    >>> x[3]
    tensor(3)

4.访问张量的长度

    >>> len(x)
5.只有一个轴的张量，形状只有一个元素
    >>> x.shape
    torch.Size([4])
    
    此时有两个元素
    tensor([[ 0,  4,  8, 12, 16],
                    [ 1,  5,  9, 13, 17],
                    [ 2,  6, 10, 14, 18],
                    [ 3,  7, 11, 15, 19]])
    >>> A.shape
    torch.Size([5, 4])

6、通过指定两个分量m和 n来创建一个形状为m×n的矩阵
    >>> A = torch.arange(20).reshape(5, 4)
    >>> A
    tensor([[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11],
            [12, 13, 14, 15],
            [16, 17, 18, 19]])
7、矩阵的转置
    >>> A.T
    tensor([[ 0,  4,  8, 12, 16],
            [ 1,  5,  9, 13, 17],
            [ 2,  6, 10, 14, 18],
            [ 3,  7, 11, 15, 19]])
8、对称矩阵（symmetric matrix）A等于其转置：A=A⊤
    >>> B = torch.tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]])
    >>> B
    tensor([[1, 2, 3],
            [2, 0, 4],
            [3, 4, 5]])
    >>> B == B.T
    tensor([[True, True, True],
            [True, True, True],
            [True, True, True]])
9、就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构
    >>> X = torch.arange(24).reshape(2, 3, 4)
    >>> X
    tensor([[[ 0,  1,  2,  3],
             [ 4,  5,  6,  7],
             [ 8,  9, 10, 11]],
    
            [[12, 13, 14, 15],
             [16, 17, 18, 19],
             [20, 21, 22, 23]]])

10、给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量
    >>> A = torch.arange(20, dtype=torch.float32).reshape(5, 4)
    >>> B = A.clone()
    >>> A, A + B
    (tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  5.,  6.,  7.],
            [ 8.,  9., 10., 11.],
            [12., 13., 14., 15.],
            [16., 17., 18., 19.]]), 
     tensor([[ 0.,  2.,  4.,  6.],
            [ 8., 10., 12., 14.],
            [16., 18., 20., 22.],
            [24., 26., 28., 30.],
            [32., 34., 36., 38.]]))

11、两个矩阵的按元素乘法称为哈达玛积（Hadamard product）（数学符号⊙）
    >>> A * B
    tensor([[  0.,   1.,   4.,   9.],
            [ 16.,  25.,  36.,  49.],
            [ 64.,  81., 100., 121.],
            [144., 169., 196., 225.],
            [256., 289., 324., 361.]])
    >>> a = 2
    >>> X = torch.arange(24).reshape(2, 3, 4)
    >>>x, a + X, (a * X).shape
    tensor([[[ 0,  1,  2,  3],
             [ 4,  5,  6,  7],
             [ 8,  9, 10, 11]],
            [[12, 13, 14, 15],
             [16, 17, 18, 19],
             [20, 21, 22, 23]]])
    (tensor([[[ 2,  3,  4,  5],
             [ 6,  7,  8,  9],
             [10, 11, 12, 13]],
            [[14, 15, 16, 17],
             [18, 19, 20, 21],
             [22, 23, 24, 25]]]), 
    torch.Size([2, 3, 4]))


12、计算其元素的和
    >>> x = torch.arange(4, dtype=torch.float32)
    >>> x, x.sum()
    (tensor([0., 1., 2., 3.]), 
     tensor(6.))

13、表示任意形状张量的元素和
    >>> A.shape, A.sum()
    (torch.Size([5, 4]), tensor(190.))


14、指定张量沿哪一个轴来通过求和降低维度
    >>> A
    tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  5.,  6.,  7.],
            [ 8.,  9., 10., 11.],
            [12., 13., 14., 15.],
            [16., 17., 18., 19.]])
    
//
+a 调用函数时指定axis=0。 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。
    >>> A_sum_axis0 = A.sum(axis=0)
    >>> A_sum_axis0, A_sum_axis0.shape
    (tensor([40., 45., 50., 55.]), torch.Size([4]))
    
+b axis=1将通过汇总所有列的元素降维（轴1）。因此，输入轴1的维数在输出形状中消失。
    >>> A_sum_axis1 = A.sum(axis=1)
    >>> A_sum_axis1, A_sum_axis1.shape
    (tensor([ 6., 22., 38., 54., 70.]), torch.Size([5]))
+c 沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和。
    >>> A.sum(axis=[0, 1])  # 结果和A.sum()相同
    tensor(190.)

15、一个与求和相关的量是平均值（mean或average）
    >>> A
    tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  5.,  6.,  7.],
            [ 8.,  9., 10., 11.],
            [12., 13., 14., 15.],
            [16., 17., 18., 19.]])

    >>> A.mean(), A.sum() / A.numel()
    (tensor(9.5000), tensor(9.5000))

    >>> A.mean(axis=0), A.sum(axis=0),  A.sum(axis=0) / A.shape[0]
    (tensor([ 8.,  9., 10., 11.]),
    tensor([40., 45., 50., 55.]), 
    tensor([ 8.,  9., 10., 11.]))

16、有时在调用函数来计算总和或均值时保持轴数不变会很有用
    >>> sum_A = A.sum(axis=1, keepdims=True)
    >>> sum_A
    tensor([[ 6.],
            [22.],
            [38.],
            [54.],
            [70.]])
    1)例如，由于sum_A在对每行进行求和后仍保持两个轴，我们可以通过广播将A除以sum_A。
    >>> A / sum_A
    tensor([[0.0000, 0.1667, 0.3333, 0.5000],
            [0.1818, 0.2273, 0.2727, 0.3182],
            [0.2105, 0.2368, 0.2632, 0.2895],
            [0.2222, 0.2407, 0.2593, 0.2778],
            [0.2286, 0.2429, 0.2571, 0.2714]])
17、如果我们想沿某个轴计算A元素的累积总和， 比如axis=0（按行计算），可以调用cumsum函数。 此函数不会沿任何轴降低输入张量的维度。
    >>> A.cumsum(axis=0)
    tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  6.,  8., 10.],
            [12., 15., 18., 21.],
            [24., 28., 32., 36.],
            [40., 45., 50., 55.]])

2.3.7. 点积（Dot Product)
    1、点积是相同位置的按元素乘积的和
        >>> x
        tensor([0., 1., 2., 3.])

        >>> y = torch.ones(4, dtype=torch.float32)
        tensor([1., 1., 1., 1.])
        >>> x, y, torch.dot(x, y)
        (tensor([0., 1., 2., 3.]), 
        tensor(6.))
    
    注意，我们可以通过执行按元素乘法，然后进行求和来表示两个向量的点积：
        >> torch.sum(x * y)
        tensor(6.)

    2、矩阵向量积Ax是一个长度为m的列向量，其第i个元素是点积a⊤ix
        >>> x
        tensor([0., 1., 2., 3.])
        >>> A
        tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.],
                [12., 13., 14., 15.],
                [16., 17., 18., 19.]])
        >>> x.shape
        torch.Size([4])
        >>> A.shape
        torch.Size([5, 4])
        >>> torch.mv(A,x)
        tensor([ 14.,  38.,  62.,  86., 110.])

    3、我们可以将矩阵-矩阵乘法AB看作是简单地执行m次矩阵-向量积，并将结果拼接在一起，形成一个n×m矩阵
        >>> A
        tensor([[ 0.,  1.,  2.,  3.],
                [ 4.,  5.,  6.,  7.],
                [ 8.,  9., 10., 11.],
                [12., 13., 14., 15.],
                [16., 17., 18., 19.]])
        >>> B = torch.ones(4, 3)
        >>> torch.mm(A, B)
        tensor([[ 6.,  6.,  6.],
                [22., 22., 22.],
                [38., 38., 38.],
                [54., 54., 54.],
                [70., 70., 70.]])
    
    4、L2范数是向量元素平方和的平方根：
        >>> u = torch.tensor([3.0, -4.0])
        >>> u
        tensor([ 3., -4.])
        >>> torch.norm(u)
        tensor(5.)
    
    L1范数，它表示为向量元素的绝对值之和： 
        >>> torch.abs(u).sum()
        tensor(7.)

    5、矩阵 的弗罗贝尼乌斯范数（Frobenius norm）是矩阵元素平方和的平方根： 
    >>> torch.norm(torch.ones((4, 9)))
    tensor(6.)


    


